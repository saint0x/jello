(* emit.ml â€” Plan serialization.
   Produces linkplan.json, linkplan.sh, and diagnostics.json. *)

open Types

let src = Logs.Src.create "jello.emit" ~doc:"Plan emitter"

module Log = (val Logs.src_log src : Logs.LOG)

(* --- JSON encoding --- *)

let string_j s = `String s
let int_j i = `Int i
let list_j f xs = `List (List.map f xs)
let option_j f = function Some v -> f v | None -> `Null

let lib_ref_j = function
  | Named n -> `Assoc [ ("type", string_j "named"); ("name", string_j n) ]
  | Path p -> `Assoc [ ("type", string_j "path"); ("path", string_j p) ]
  | Framework f ->
      `Assoc [ ("type", string_j "framework"); ("name", string_j f) ]

let lib_kind_j = function
  | Static_lib -> string_j "static"
  | Shared_lib -> string_j "shared"

let lib_resolved_j r =
  `Assoc
    [
      ("reference", lib_ref_j r.reference);
      ("path", string_j r.path);
      ("kind", lib_kind_j r.kind);
      ( "arch",
        option_j (fun a -> string_j (arch_to_string a)) r.detected_arch );
    ]

let input_j = function
  | Object p -> `Assoc [ ("type", string_j "object"); ("path", string_j p) ]
  | Archive p -> `Assoc [ ("type", string_j "archive"); ("path", string_j p) ]
  | Shared_object p ->
      `Assoc [ ("type", string_j "shared_object"); ("path", string_j p) ]
  | Linker_script p ->
      `Assoc [ ("type", string_j "linker_script"); ("path", string_j p) ]
  | Response_file p ->
      `Assoc [ ("type", string_j "response_file"); ("path", string_j p) ]
  | Lib r -> `Assoc [ ("type", string_j "lib"); ("ref", lib_ref_j r) ]
  | Raw_input p ->
      `Assoc [ ("type", string_j "raw"); ("path", string_j p) ]

let triple_j t =
  `Assoc
    [
      ("arch", string_j (arch_to_string t.arch));
      ("vendor", option_j string_j t.vendor);
      ("os", string_j (os_to_string t.os));
      ("env", option_j (fun e -> string_j (env_to_string e)) t.env);
      ("string", string_j (triple_to_string t));
    ]

let fix_j f =
  `Assoc
    [
      ("description", string_j f.description);
      ("confidence", string_j (confidence_to_string f.confidence));
    ]

let diagnostic_j d =
  `Assoc
    [
      ("severity", string_j (severity_to_string d.severity));
      ("code", string_j d.code);
      ("message", string_j d.message);
      ("evidence", list_j string_j d.evidence);
      ("fixes", list_j fix_j d.fixes);
    ]

(* Emit the full link plan as JSON *)
let json plan =
  let j =
    `Assoc
      [
        ("version", string_j "1");
        ("backend", string_j (backend_to_string plan.backend));
        ("backend_path", string_j plan.backend_path);
        ("triple", triple_j plan.triple);
        ("link_mode", string_j (link_mode_to_string plan.link_mode));
        ("output", string_j plan.output);
        ("inputs", list_j input_j plan.inputs);
        ("search_paths", list_j string_j plan.search_paths);
        ("resolved_libs", list_j lib_resolved_j plan.resolved_libs);
        ("sysroot", option_j string_j plan.sysroot);
        ("dynamic_linker", option_j string_j plan.dynamic_linker);
        ("fixes_applied", list_j fix_j plan.fixes_applied);
        ("diagnostics", list_j diagnostic_j plan.diagnostics);
        ("raw_args", list_j string_j plan.raw_args);
        ("backend_args", list_j string_j plan.backend_args);
      ]
  in
  Yojson.Safe.pretty_to_string ~std:true j

(* Emit diagnostics as JSON *)
let diagnostics_json diags =
  let j = `Assoc [ ("diagnostics", list_j diagnostic_j diags) ] in
  Yojson.Safe.pretty_to_string ~std:true j

(* --- Shell script emission --- *)

(* Shell-escape a string *)
let shell_escape s =
  if
    String.for_all
      (fun c ->
        (c >= 'a' && c <= 'z')
        || (c >= 'A' && c <= 'Z')
        || (c >= '0' && c <= '9')
        || c = '-' || c = '_' || c = '.' || c = '/' || c = '=' || c = ','
        || c = '+' || c = ':')
      s
  then s
  else Printf.sprintf "'%s'" (String.concat "'\"'\"'" (String.split_on_char '\'' s))

(* Emit a replay shell script *)
let shell plan =
  let buf = Buffer.create 1024 in
  let add s = Buffer.add_string buf s in
  let addln s =
    Buffer.add_string buf s;
    Buffer.add_char buf '\n'
  in
  addln "#!/bin/sh";
  addln "# LinkPlan replay script generated by gel";
  addln (Printf.sprintf "# Target: %s" (triple_to_string plan.triple));
  addln (Printf.sprintf "# Backend: %s" (backend_to_string plan.backend));
  addln (Printf.sprintf "# Output: %s" plan.output);
  addln "";
  if plan.fixes_applied <> [] then (
    addln "# Fixes applied:";
    List.iter
      (fun f ->
        addln (Printf.sprintf "#   [%s] %s"
          (confidence_to_string f.confidence) f.description))
      plan.fixes_applied;
    addln "");
  add (shell_escape plan.backend_path);
  add " \\\n";
  List.iteri
    (fun i arg ->
      add "  ";
      add (shell_escape arg);
      if i < List.length plan.backend_args - 1 then add " \\\n"
      else add "\n")
    plan.backend_args;
  Buffer.contents buf

(* Write plan artifacts to a directory *)
let write_artifacts ~dir plan diags =
  let open Bos in
  let dir = Fpath.v dir in
  let* _ = OS.Dir.create ~path:true dir in
  let* () =
    OS.File.write
      Fpath.(dir / "linkplan.json")
      (json plan)
  in
  let* () =
    OS.File.write
      Fpath.(dir / "linkplan.sh")
      (shell plan)
  in
  let* () =
    OS.File.write
      Fpath.(dir / "diagnostics.json")
      (diagnostics_json diags)
  in
  (* Make shell script executable *)
  let _ =
    OS.Cmd.run
      Cmd.(v "chmod" % "+x" % Fpath.to_string Fpath.(dir / "linkplan.sh"))
  in
  Log.info (fun m ->
      m "Wrote plan artifacts to %s" (Fpath.to_string dir));
  Ok ()
